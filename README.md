# Universal Productivity Hub for Bug Tracking 
#### (pronounced upbeat)
### AI-Assisted Roadmap

`"It doesn't matter if a cat is black or white, if it catches mice it's a good cat"`

---

### **Comprehensive Roadmap for Uphbt: A .NET 9 Web API with Rich Domain Model**

**Project Goal: To develop a robust, maintainable, and scalable Universal Productivity Hub Bug Tracker (Uphbt) API and its accompanying frontends using modern .NET practices, adhering to a layered architecture with a rich domain model, and leveraging AI for accelerated development.**

---

**Overall Technology Stack:**

* **Backend: .NET Web API (latest LTS \- .NET 9\) with C\# 12 and modern syntax (e.g., file-scoped namespaces, Nullable Reference Types), Swagger/OpenAPI for API Documentation. Business logic will be primarily implemented in the Rich Domain Model layer, with the Service layer handling orchestration and logic that cannot be performed by entities themselves.**  
* **Database: SQL Server**  
* **ORM: Entity Framework Core**  
* **Frontend 1 (Angular): Bug Tracker (Full Features) \- Angular 19 (LTS) \- Using ReactiveFormsModule and Angular Material UI Library (with Proxy for Dev)**  
* **Frontend 2 (React): Bug Tracker (Full Features \- Mirror of Angular) \- React 19 (Stable) \- Using React Hook Form and Material UI (MUI) Library (with Proxy for Dev)**  
* **Authentication: JWT with Refresh Tokens & BCrypt.Net-Next for password hashing**  
* **Real-time: SignalR**  
* **Internationalization & Localization (i18n/l10n):**  
  * **.NET: Microsoft.Extensions.Localization, Microsoft.AspNetCore.Localization**  
  * **Angular: ngx-translate**  
  * **React: i18next & react-i18next**  
* **Testing:**  
  * **.NET: xUnit, Moq, Microsoft.AspNetCore.Mvc.Testing**  
  * **Angular: Jasmine, Karma, Angular Testing Bed, HttpClientTestingModule**  
  * **React: Jest, React Testing Library, MSW (Mock Service Worker)**  
  * **E2E: Cypress or Playwright**  
* **Deployment (Local/Shareable): Docker & Docker Compose**  
* **AI Strategy: Extensive use of LLM for code generation, test scaffolding, cross-framework translation, debugging, and concept explanation. Critical human review and understanding for all AI-generated code.**  
* **Source Control: Git (with a feature branching workflow)**  
* **Estimated Timeline: 4 \- 6 months (aggressive, AI-assisted pace)**

  ---

**Git Workflow Strategy (Feature Branching Model) For a project with three distinct repositories (.NET Backend, Angular Frontend, React Frontend), a feature branching workflow is highly recommended. This allows independent development and testing of features before merging into stable branches.**

**Repository Setup: Three separate Git repositories:**

* **`uphbt-backend` (.NET Web API)**  
* **`uphbt-angular-frontend` (Angular App)**  
* **`uphbt-react-frontend` (React App)**

**Each repository will have at least the following long-lived branches:**

* **`main` (or `master`): Represents the latest production-ready code. Only merged into via pull requests.**  
* **`develop`: Integration branch for ongoing development. Features are merged here.**

**Feature Branches: For each new feature, bug fix, or major refactor, create a new branch from `develop`. Naming convention: `feature/your-feature-name`, `bugfix/issue-description`, `refactor/area-name`.**

**Development Cycle:**

* **Pull `develop`: Always start by pulling the latest `develop` branch.**  
* **Create Feature Branch: `git checkout -b feature/my-new-feature develop`**  
* **Develop & Commit: Work on your feature. Make frequent, small, atomic commits with clear messages. `git add .`, `git commit -m "feat: implemented user registration form"`**  
* **Push to Remote: Regularly push your feature branch to the remote: `git push origin feature/my-new-feature`**  
* **Keep up with `develop`: Periodically pull `develop` into your feature branch to stay updated and resolve conflicts early: `git pull origin develop` (or `git pull origin develop --rebase` for a cleaner history if preferred).**

**Code Review & Merge (Pull Requests):**

* **When a feature is complete and tested locally, push it to the remote.**  
* **Create a Pull Request (PR) from your `feature/branch` to `develop` in your Git hosting platform (e.g., GitHub, GitLab, Azure DevOps).**  
* **Mandatory Code Review: At least one other team member should review the code.**  
* **Automated Checks: (Future CI/CD integration) PRs should trigger automated tests and static analysis.**  
* **Merge: Once approved and all checks pass, merge the feature branch into `develop`. Use "Squash and Merge" or "Rebase and Merge" for a cleaner `develop` history, or "Merge Commit" for retaining all feature branch commits.**

**Releases (Optional but Recommended):**

* **When `develop` reaches a stable point for a release, create a `release/vX.Y.Z` branch from `develop`.**  
* **Perform final testing, bug fixes (committed directly to the release branch), and version updates on this branch.**  
* **When ready, merge `release/vX.Y.Z` into both `main` and `develop`. Tag `main` with the release version.**

**Hotfixes:**

* **For urgent production bugs, create `hotfix/issue-description` branches directly from `main`.**  
* **Once fixed, merge the hotfix branch back into both `main` and `develop`. Tag `main`.**

**Important Considerations for Three Repositories:**

* **Feature Alignment: For a single user story (e.g., "Implement Bug Reporting"), you might have a feature branch in each of the three repositories. You'll need to coordinate merging these related branches. A common strategy is to merge the backend feature first, then the frontend(s).**  
* **Version Control for Dependencies: Ensure `package.json` (Angular/React) and `.csproj` files (.NET) are committed and specify exact (or range-controlled) dependencies.**

  ---

  #### **Phase 1: Core Foundation, Security & i18n Setup (Month 1 \- 1.5)**

**Goal: Establish a secure, robust backend and foundational authentication/authorization. Set up the basic i18n/l10n framework across all layers and both frontends, using AI to accelerate initial setup.**

**1.1. Backend (.NET) & Database Setup**

* **Action: Initial project setup with a Rich Domain Model design, emphasizing persistence-ignorance (POCOs without EF Core specific attributes/interfaces in the domain layer). Domain entities will encapsulate their own behavior, containing methods that represent business operations and enforce invariants. Define internal primary keys as `long` (mapping to BIGINT IDENTITY in SQL Server) and all foreign keys should also be `long`. Each entity (e.g., `User`, `Bug`, `Comment`) should also have a `Guid PublicId` property that is unique and will be exposed to the application layer. Include a `byte[] RowVersion` property on `User` for optimistic concurrency. Layered architecture, core DB schema (Users), EF Core configuration, JWT authentication/authorization, password hashing with BCrypt.Net-Next, server-side i18n. Crucially, generate and apply the initial Entity Framework Core database migration. All C\# code must fully leverage Nullable Reference Types (NRTs) to explicitly define nullability, ensuring properties and method return types reflect whether `null` is a valid state or value. Integrate Swagger/OpenAPI middleware for API documentation and interactive testing.**  
* **Specifically for Identity: Customize `ApplicationUser` to inherit from `IdentityUser<long>` and add `FullName` (string, non-nullable) and `DateHired` (`DateTime?`, nullable) properties directly to it, along with the `Guid PublicId` property (non-nullable). For roles, directly use `ApplicationRole` inheriting from `IdentityRole<long>` and leverage ASP.NET Core Identity's built-in role management mechanisms.**  
* **Role Seeding: Pre-seed the roles "user" and "admin" using `RoleManager<ApplicationRole>` in `Program.cs` (or a dedicated data seeding class) during application startup.**  
* **Optimal Prompt(s):**  
  * **"Provide the `dotnet` CLI commands to generate a .NET 9 solution named 'Uphbt'. Then, generate the following projects within this solution: 'Uphbt.Api' (a webapi project with controllers), 'Uphbt.Services' (a class library), 'Uphbt.Data' (a class library), and 'Uphbt.Domain' (a class library). After project creation, provide the `dotnet add reference` commands to set up the following project references: `Uphbt.Api` \-\> `Uphbt.Services`, `Uphbt.Api` \-\> `Uphbt.Data`, `Uphbt.Services` \-\> `Uphbt.Data`, `Uphbt.Services` \-\> `Uphbt.Domain`, `Uphbt.Data` \-\> `Uphbt.Domain`. Ensure the generated solution and projects are compatible with .NET 9."**  
  * **"Generate a complete .NET 9 Web API solution structure (assuming previous `dotnet new` commands were executed) with the solution name 'Uphbt' for a layered architecture (Api, Services, Data, Domain) with Entity Framework Core 9 and SQL Server, using C\# 12 and modern syntax (e.g., file-scoped namespaces, Nullable Reference Types). Design \*\*domain entities (e.g., `User`) as Plain C\# Objects (POCOs) in the Domain project, but ensure they are set up to be Rich Domain Models. This means properties should primarily use private setters where changes are driven by public business methods defined within the entity itself. Entities should include constructors to enforce valid initial states. They should ensure persistence-ignorance, without any EF Core attributes or base classes in the Domain project. All internal primary key Ids should be `long` (mapping to BIGINT IDENTITY in SQL Server) and all foreign keys should also be `long`. Each entity (e.g., `User`, `Bug`, `Comment`) should also have a `Guid PublicId` property that is unique and will be exposed to the application layer. Include a `byte[] RowVersion` property on `User` for optimistic concurrency. Provide `appsettings.json` for database connection, `Program.cs` setup, and a `DbContext` that maps these POCOs and configures `Id` as `IDENTITY`, adds a unique non-clustered index on `PublicId`, and sets `RowVersion` as a concurrency token using Fluent API in the Data project. Ensure all string properties are initialized to `string.Empty` or explicitly marked nullable (`string?`) where `null` is a valid state. Methods should return non-nullable types unless a `null` return is an expected outcome (e.g., for 'not found' scenarios). Include a `.gitignore` file suitable for a .NET project within the 'Uphbt' solution. Configure SwaggerGen and SwaggerUI in `Program.cs` for API documentation and testing. Then, provide the `dotnet ef migrations` commands to: (1) add the initial migration named 'InitialCreate', and (2) update the database to apply this migration."**  
  * **"Extend the previous .NET 9 API within the 'Uphbt' solution to include JWT authentication and refresh token management using ASP.NET Core Identity customized to use `long` as the primary key type for `ApplicationUser` and `ApplicationRole`, using C\# 12 and modern syntax (e.g., file-scoped namespaces, Nullable Reference Types). My `ApplicationUser` class should also be designed as a Rich Domain Model and have `FullName` (string, non-nullable), `DateHired` (DateTime?, nullable), and a `Guid PublicId` property (non-nullable). Provide `AuthController` with `/register`, `/login`, `/refresh-token` endpoints. Include DTOs for request/response. Ensure the service layer (e.g., AuthService) performs business logic that cannot be done on the `ApplicationUser` entity itself (e.g., password hashing via `BCrypt.Net-Next`, sending welcome emails, role assignment/checking). The `ApplicationUser` entity's own methods will handle its internal state changes (e.g., changing its own `FullName`). Ensure all DTO properties and service method return types correctly reflect their nullability using NRTs (e.g., `string`, `string?`, `AuthResponseDto?`). Ensure user registration generates and stores the `long` internal `Id` and the `Guid PublicId` and that login/update endpoints primarily interact with the `PublicId` from the client but translate to the internal `long` `Id` for database operations, passing `FullName` and `DateHired` as standard user properties. Implement password hashing using `BCrypt.Net-Next` and store refresh tokens in the database. Configure JWT bearer authentication in `Program.cs`. Ensure roles are included in JWT claims. Crucially, in `Program.cs` or a dedicated data seeding class, add logic to pre-seed the `admin` and `user` roles using `RoleManager<ApplicationRole>` if they do not already exist upon application startup. Show the minimal required custom `ApplicationUser`, `ApplicationRole`, and `ApplicationDbContext` setup for this Identity customization, and the role seeding logic. Ensure Swagger UI is configured to allow testing of authenticated endpoints (e.g., using a JWT Bearer token field)."**  
  * **"Integrate `Microsoft.Extensions.Localization` into the Uphbt.Api project. Set up `RequestLocalizationMiddleware` to detect culture from `Accept-Language` header. Provide an example `Errors.en-US.resx` and `Errors.es.resx` for a localized validation message like 'Username is required'. Show how to inject `IStringLocalizer` into a controller and return a localized error. Ensure all string properties in generated classes and method parameters/return types correctly use NRT annotations. All C\# code should adhere to C\# 12 and modern syntax (e.g., file-scoped namespaces, Nullable Reference Types)."**  
* **Testing (AI-Assisted):**  
  * **Optimal Prompt(s):**  
    * **"Generate xUnit unit tests for the `AuthService` in a Uphbt.Services project. Mock `UserManager`, `SignInManager`, and `RefreshTokenRepository`. Cover scenarios for user registration (success, existing user, including `FullName` and `DateHired` data, and verifying correct role assignment upon registration like 'user' role by default), user login (success, invalid credentials), and refresh token validation (success, expired token). Verify `BCrypt.Net-Next` is used for hashing and validation and that user IDs are managed using the `long` internal ID for DB operations and `Guid PublicId` for API interactions. Also, verify `FullName` and `DateHired` are correctly stored and retrieved, and that role claims are present in generated JWTs. The tests should cover both domain logic (if any is simple and directly testable on `ApplicationUser` entity's methods) and service orchestration logic. Ensure all test code correctly handles `null` values for nullable types and assertions for non-nullable types, demonstrating an understanding of Nullable Reference Types. All test code should adhere to C\# 12 and modern syntax (e.g., file-scoped namespaces)."**  
    * **"Create an integration test for the Uphbt.Api `AuthController` using `Microsoft.AspNetCore.Mvc.Testing`. Test the `/register` endpoint (success, validation failure, including `FullName` and `DateHired`, and verifying the default role is assigned), `/login` endpoint (success, invalid credentials). Add a test case for user update that involves optimistic concurrency: try to update the same user record twice simultaneously (or with a stale `RowVersion`) and assert that a `DbUpdateConcurrencyException` (or 409 Conflict) is returned. Ensure all API calls use the `Guid PublicId` for identification and correctly handle `FullName` and `DateHired` data and roles. Verify that DTOs and API responses correctly reflect nullability with NRTs. All test code should adhere to C\# 12 and modern syntax (e.g., file-scoped namespaces)."**  
    * **"Write an integration test for the localized error messages in a Uphbt.Api. Send a request to a validation-protected endpoint with `Accept-Language: es` and `Accept-Language: en-US` headers, and assert that the returned error message matches the content in `Errors.es.resx` and `Errors.en-US.resx` respectively. Ensure all string properties and method returns in test setup and assertions correctly use NRT annotations. All test code should adhere to C\# 12 and modern syntax (e.g., file-scoped namespaces)."**

**1.2. Frontend (Angular) Setup \- For Bug Tracker**

* **Action: Angular project setup, routing, basic layout, core auth service/interceptor/guards, `ngx-translate` i18n setup, Angular Material and `ReactiveFormsModule` integration, and proxy configuration for API calls. Components should be designed to handle and send the `Guid PublicId` for all entities (Users, Bugs, Comments) and `RowVersion` for updates. User-related forms and displays will include `FullName` and `DateHired` (handling `DateHired` as potentially null). Role-based authorization will be handled using JWT claims (e.g., role: "admin").**  
* **Optimal Prompt(s):**  
  * **"Generate an Angular 19 application with a basic routing setup (e.g., /login, /bugs, /bugs/report). Include an `AuthService` for JWT handling, an `AuthInterceptor` to add bearer tokens, and an `AuthGuard` to protect routes. Show how to configure these in `app.module.ts` (or standalone equivalent). Integrate Angular Material and `ReactiveFormsModule` for form handling. Ensure services are designed to handle `Guid PublicId`s for all entities and `byte[]` `RowVersion` data types in their models. User models should include `FullName` (string) and `DateHired` (string | null, for display/input). Include a `.gitignore` file suitable for an Angular project."**  
  * **"Create an Angular 19 `LoginComponent` and `RegisterComponent` using Angular Material form fields (e.g., `mat-form-field`, `mat-input`) and `ReactiveFormsModule`. Include validation for email, password, `FullName` and `DateHired` (as a `mat-datepicker` for `DateHired`, ensuring it handles `null` values correctly). Show how to integrate with `AuthService` for login/registration. Ensure all labels and error messages are translated using `ngx-translate`. The `AuthService` should expect the user's `PublicId` (Guid), `FullName`, `DateHired` (which might be `null`), and their assigned roles (e.g., an array of strings like \['user'\]) in the login/registration response."**  
  * **"Integrate `ngx-translate/core` and `ngx-translate/http-loader` into an Angular 19 application. Show configuration in `app.module.ts`. Provide example `en.json` and `es.json` translation files for 'login.title', 'welcome.message', 'user.fullName', 'user.dateHired'. Show how to use `TranslatePipe` in a template and `TranslateService` for dynamic translation, and a simple language switcher component. Ensure the translation system correctly handles and displays `null` or undefined values for optional fields like `DateHired` gracefully."**  
  * **"Generate an Angular CLI proxy configuration file (`proxy.conf.json`) to redirect all `/api` requests to a .NET 9 backend running on `http://localhost:5000` (or your backend port)."**  
* **Testing (AI-Assisted):**  
  * **Optimal Prompt(s):**  
    * **"Write Jasmine/Karma unit tests for the Angular `AuthService`. Test methods like `login()`, `logout()`, `getToken()`, and `isAuthenticated()`. Ensure that `Guid` types (for `PublicId`), `FullName`, `DateHired` (including `null` scenarios), and roles are correctly handled in mock API responses."**  
    * **"Generate Jasmine/Karma unit tests for the Angular `RegisterComponent`. Test ReactiveForm validation (including `FullName` and `DateHired` `null` handling), submission success/failure, and that Angular Material elements render correctly. Test that changing the language via `TranslateService.use()` updates the displayed text in the component's template. Verify that `FullName` and `DateHired` are correctly captured and sent in the registration payload, and that roles received in the response are correctly processed, paying attention to potential `null` values for `DateHired`."**

**1.3. Frontend (React) Setup \- For Bug Tracker**

* **Action: React project setup, routing, basic layout, `useAuth` hook/context, `axios` interceptors, `ProtectedRoute`, `i18next` i18n setup, React Hook Form and Material UI (MUI) integration, and proxy configuration for API calls. Components should be designed to handle and send the `Guid PublicId` for all entities and `RowVersion` for updates. User-related forms and displays will include `FullName` and `DateHired` (handling `DateHired` as potentially null). Role-based authorization will be handled using JWT claims (e.g., role: "admin").**  
* **Optimal Prompt(s):**  
  * **"Generate a React 19 application structure using Vite/CRA with `react-router-dom` for routing (/login, /bugs, /bugs/report). Include a `useAuth` hook/AuthContext for JWT handling, and configure `axios` interceptors to automatically add bearer tokens. Provide a basic `Login` component and `Register` component, and a `ProtectedRoute` component to guard routes. Integrate Material UI (MUI) for components and `react-hook-form` for form handling. Ensure data models used in hooks and components handle `Guid PublicId`s for all entities and `byte[]` `RowVersion` data types. User models should include `FullName` (string) and `DateHired` (string | null, for display/input, using MUI `DatePicker` that handles `null` correctly). Include a `.gitignore` file suitable for a React project."**  
  * **"Create a React 19 `Login` functional component and `Register` functional component using MUI components (e.g., `TextField`, `Button`, `DatePicker`) and `react-hook-form` for form management. Implement validation for email, password, `FullName` and `DateHired` (ensuring the `DatePicker` component correctly binds and sends `null` when no date is selected). Show how to integrate with a `useAuth` hook for login/registration. Ensure all labels and error messages are translated using `useTranslation` from `react-i18next`. The `useAuth` hook should expect the user's `PublicId` (Guid), `FullName`, `DateHired` (which might be `null`), and their assigned roles (e.g., an array of strings like \['user'\]) in the login/registration response."**  
  * **"Integrate `i18next` and `react-i18next` into a React 19 application. Configure `i18next` instance to load translations from `public/locales` using `i18next-http-backend`. Provide example `en/translation.json` and `es/translation.json` for 'login.title', 'welcome.message', 'user.fullName', 'user.dateHired'. Show how to use `useTranslation` hook in a functional component and implement a simple language switcher. Ensure the translation system correctly handles and displays `null` or undefined values for optional fields like `DateHired` gracefully."**  
  * **"Generate a proxy configuration for a React application (either `setupProxy.js` for CRA or `vite.config.js` for Vite) to redirect all `/api` requests to a .NET 9 backend running on `http://localhost:5000` (or your backend port)."**  
* **Testing (AI-Assisted):**  
  * **Optimal Prompt(s):**  
    * **"Write Jest/React Testing Library unit tests for the React `useAuth` hook. Test state changes for login/logout, token storage/retrieval, and `isAuthenticated` status. Ensure that `Guid` types (for `PublicId`), `FullName`, `DateHired` (including `null` scenarios), and roles are correctly handled in mock API responses."**  
    * **"Generate Jest/React Testing Library tests for the React `Register` component. Test form validation (including `FullName` and `DateHired` `null` handling with `MUI DatePicker` interaction), submission success/failure, and that MUI components render correctly. Test that changing the language (by mocking `i18n.changeLanguage`) updates the displayed text in the component's template. Verify that `FullName` and `DateHired` are correctly captured and sent in the registration payload, and that roles received in the response are correctly processed, paying attention to potential `null` values for `DateHired`."**

    ---

    #### **Phase 2: Bug Tracker Core Functionality & i18n Integration (Months 1.5 \- 4\)**

**Goal: Implement full CRUD operations, file attachments, commenting, and real-time updates for bugs, with comprehensive testing and full i18n/l10n integration. Leverage AI heavily for feature generation and cross-framework mirroring.**

**2.1. Backend (.NET) \- Bug & Comment Management \+ Real-time (API)**

* **Action: Define `Bug`, `BugAttachment`, `Comment` entities as Rich Domain Models in the domain layer. This means they will encapsulate their own internal business rules (e.g., a `Bug` knows how to change its `Status`, a `Comment` knows how to `EditContent`). All internal primary keys and foreign keys should be `long` (`BIGINT`). Each entity should also have a `Guid PublicId`. Include a `byte[] RowVersion` property for optimistic concurrency. Implement CRUD endpoints where the service layer orchestrates calls to these rich domain entities' methods and handles logic that cannot be performed by the entity itself (e.g., authorization, external notifications, cross-aggregate consistency). These services will accept `Guid PublicId`s and validate `RowVersion` on update/delete operations. Support file upload/download, generic commenting, SignalR Hub. Crucially, all joins and foreign key relationships in the database queries will be performed on the internal `long` keys. All C\# code must fully leverage Nullable Reference Types (NRTs) to explicitly define nullability, ensuring properties and method return types reflect whether `null` is a valid state or value.**  
* **Optimal Prompt(s):**  
  * **"Generate a complete .NET 9 Web API CRUD for a `Bug` entity (`Id`: `long` (PK, Clustered Index), `PublicId`: `Guid` (Unique, Non-Clustered), `ProjectId`: `long` (FK), Title (string, non-nullable), Description (string?, nullable), Severity(Enum: Low, Medium, High), Status(Enum: Open, InProgress, Closed), AssignedToUserId: `long` (FK, nullable), ReportedByUserId: `long` (FK, non-nullable), ReportedDate, LastUpdatedDate, `byte[] RowVersion`). Define `Bug` as a Rich Domain Model in the Domain layer, meaning it will have private setters for its properties and public methods (e.g., `AssignTo(User assignee)`, `Resolve()`, `Reopen()`) to encapsulate its own business logic and state transitions. The service layer will orchestrate operations, retrieving the `Bug` and `User` entities, calling the `Bug`'s methods, and handling any logic that doesn't fit within the `Bug` entity itself (e.g., user role checks, sending notifications, complex querying). Include DTOs, controller, service. Ensure all string properties are initialized to `string.Empty` or explicitly marked nullable (`string?`) where `null` is a valid state. Methods should return non-nullable types unless a `null` return is an expected outcome (e.g., for 'not found' scenarios). Ensure update and delete operations in the service/repository use the provided `RowVersion` for optimistic concurrency checks. All API endpoints should accept `PublicId` for identification. Backend services should translate the `PublicId` to `Id` for database queries and all foreign key relationships (`ProjectId`, `AssignedToUserId`, `ReportedByUserId`) should be handled using `long` type internally. Support file attachments (upload and download) using `IFormFile` to a local directory or Azure Blob Storage. Provide the API structure for file upload and download. Ensure Swagger documentation for the `Bug` endpoints correctly reflects the usage of `Guid PublicId` and `RowVersion`, and explicitly states parameter requirements and response types. All generated C\# code should use C\# 12 and modern syntax (e.g., file-scoped namespaces, Nullable Reference Types)."**  
  * **"Extend the .NET 9 API with a generic `Comment` entity (`Id`: `long` (PK, Clustered Index), `PublicId`: `Guid` (Unique, Non-Clustered), `BugId`: `long` (FK), Content (string, non-nullable), CreatedByUserId: `long` (FK, non-nullable), CreatedDate, `byte[] RowVersion`). Define `Comment` as a Rich Domain Model in the Domain layer, allowing it to encapsulate its own logic (e.g., `EditContent(string newContent)`). Provide endpoints for `GET /api/bugs/{bugPublicId}/comments` and `POST /api/bugs/{bugPublicId}/comments`, and `PUT`/`DELETE` for comments, ensuring `RowVersion` handling for updates/deletes and that all foreign keys (`BugId`, `CreatedByUserId`) are handled using `long` type internally. The service layer will orchestrate comment operations, calling methods on the `Comment` entity and handling cross-cutting concerns (e.g., `SignalR` notifications). Include DTOs and services. Ensure `BugId` is validated against existing bugs. Ensure all DTO properties and service method return types correctly reflect their nullability using NRTs. Ensure Swagger documentation for `Comment` endpoints clearly indicates the `PublicId` and `RowVersion` parameters where applicable. All generated C\# code should use C\# 12 and modern syntax (e.g., file-scoped namespaces, Nullable Reference Types)."**  
  * **"Integrate SignalR into the Uphbt.Api project. Create a `BugHub` that allows clients to subscribe to specific `BugPublicId`s or `ProjectPublicId`s. Show how to broadcast messages (e.g., 'new\_comment\_added', 'bug\_status\_changed') to all clients connected to a bug/project whenever a new comment is added or a bug status changes. Ensure messages sent from the hub are localized using `IStringLocalizer` based on the recipient's stored preference or a default. This real-time notification is a cross-cutting concern handled by the service layer, separate from the domain entity's core logic, which only updates the entity's state. Ensure all method parameters and return types in the hub correctly use NRT annotations. All generated C\# code should use C\# 12 and modern syntax (e.g., file-scoped namespaces, Nullable Reference Types)."**  
* **Testing (AI-Assisted):**  
  * **Optimal Prompt(s):**  
    * **"Generate xUnit unit tests for `BugService` in the Uphbt.Services project (CRUD, validation, file upload logic, comment service logic). Mock `IFileStorageService` and `IBugHubContext` (for SignalR). Ensure tests operate on rich domain models by calling their behavior methods and verifying their internal state changes, rather than directly manipulating properties. Crucially, write tests for optimistic concurrency failures for `Bug` and `Comment` updates/deletes, asserting that the correct exceptions/error responses are returned when `RowVersion` is stale. Verify that API calls use `Guid PublicId` for identification, and internal service logic correctly translates to and from `long` internal IDs for database interactions. All test code should correctly handle `null` values for nullable types and assert on non-nullable types, demonstrating an understanding of Nullable Reference Types. All test code should adhere to C\# 12 and modern syntax (e.g., file-scoped namespaces)."**  
    * **"Create integration tests for the .NET 9 Uphbt.Api `BugController` and `CommentController`. Test file upload/download. Test comment submission to bugs. Test SignalR hub integration: connect a test client, invoke a method, and assert message is broadcast with correct localized content. Include integration tests that verify optimistic concurrency for bug and comment updates/delates (e.g., two concurrent update attempts, one fails). Ensure all requests use `Guid PublicId` and responses return `Guid PublicId` for all entities, and that user-related fields (`FullName`, `DateHired` \- handling `null` for `DateHired`) are correctly displayed in relevant DTOs/responses. All test code should correctly handle `null` values for nullable types and assert on non-nullable types. All test code should adhere to C\# 12 and modern syntax (e.g., file-scoped namespaces)."**

**2.2. Frontend (Angular) \- Bug Tracker Features (Full Implementation)**

* **Action: Implement UI for bug reporting/tracking, file attachments, commenting, real-time updates using Angular Material and `ReactiveFormsModule`. All forms for updating entities must include and send the `Guid PublicId` and the `RowVersion` from the last fetched state. Implement logic to detect and inform the user about concurrency conflicts (stale data). User-related displays (e.g., assignee/reporter) will show `FullName` (handling `DateHired` as potentially null). Implement role-based UI elements (e.g., hide/show buttons based on user roles like 'admin').**  
* **Optimal Prompt(s):**  
  * **"Generate an Angular 19 component for a `BugListComponent` that fetches bugs from `/api/bugs` (receiving `Guid PublicId`s and `RowVersion`), displays them in an Angular Material table (`mat-table`), and allows viewing details, editing, and deleting. Include search and filter by status/severity/assignee (displaying `FullName` for assignees/reporters, but sending their `PublicId` for filtering), sorting, and pagination. Ensure all labels and messages are translated using `ngx-translate`. Show how to conditionally render an 'Edit' or 'Delete' button based on the logged-in user's role (e.g., only 'admin' or 'project\_manager' roles can see them). Ensure all data structures handle `null` values correctly where applicable (e.g., for optional descriptions, `DateHired`)."**  
  * **"Create an Angular 19 component for `BugReportFormComponent` (for new bugs) and `BugEditFormComponent` (for existing bugs) using Angular Material form fields (`mat-form-field`, `mat-input`, `mat-select`) and `ReactiveFormsModule`. The `BugEditFormComponent` must fetch the bug details (including its `PublicId` and `RowVersion`). When submitting updates, the stored `PublicId` and `RowVersion` must be included in the payload. Implement error handling to detect 409 Conflict responses (concurrency errors) and display a user-friendly message, prompting the user to refresh and re-apply changes if desired. All text must be translated with `ngx-translate`. Ensure user selection for `AssignedTo` and `ReportedBy` fields displays `FullName` but internally uses `Guid PublicId` for data binding and API calls. Also, show how to disable/enable certain form fields based on the user's role. Ensure all form controls correctly handle `null` or empty values for optional fields like `Description` or `DateHired`."**  
  * **"Generate an Angular 19 component for `BugDetailComponent`. Display bug details using Angular Material cards/layout, a list of comments, and attachments with download links. When viewing, store the bug's `PublicId` and `RowVersion`. Allow adding new comments using a ReactiveForm; if comments have `PublicId` and `RowVersion`, handle those too. Integrate SignalR client to receive real-time updates for new comments. Ensure all text and messages are translated. Display `FullName` for bug assignees, reporters, and comment creators. Show how to conditionally display 'Delete Comment' button only for 'admin' users or the comment creator. Ensure all displayed data (e.g., bug description, assignee, DateHired) correctly handles `null` or undefined values."**  
* **Testing (AI-Assisted):**  
  * **Optimal Prompt(s):**  
    * **"Generate Jasmine/Karma unit tests for the Angular `BugListComponent`. Test rendering with mock data (including `Guid PublicId`s and `RowVersion`, and user `FullName`), search/filter/sort functionality, pagination, and correct translation of UI elements, specifically verifying Angular Material table interactions. Ensure filtering by user `PublicId` displays `FullName` correctly. Add tests to verify conditional rendering of 'Edit'/'Delete' buttons based on user roles."**  
    * **"Create Jasmine/Karma unit tests for the Angular `BugReportFormComponent` and `BugEditFormComponent`. Test ReactiveForm validation (including `RowVersion` presence for updates). Crucially, test the component's handling of 409 Conflict responses, verifying that it displays the correct user message and allows for refresh/retry. Test integration with `FullName` display for user selection. Verify that `Guid PublicId` and `RowVersion` are correctly sent in update payloads and that conditional field enabling/disabling based on roles works as expected."**  
    * **"Write Jasmine/Karma unit tests for the Angular `BugDetailComponent`. Test display of bug details, comments, and attachments. Test the comment ReactiveForm submission. Verify SignalR client integration, asserting that the component correctly processes real-time updates (e.g., new comment added). Ensure conditional display of 'Delete Comment' button based on user roles."**

    ---

    #### **Phase 3: Advanced Features, Performance, Monitoring & Deployment (Months 4 \- 6\)**

**Goal: Implement remaining complex features, optimize for performance, establish robust monitoring, and automate deployment processes to prepare for production.**

**3.1. Advanced Backend Features (API)**

* **Action: Implement background processing for long-running or asynchronous tasks (e.g., complex report generation, bulk user imports) using a library like Hangfire or a simple `BackgroundService`. Develop a caching strategy (e.g., using Redis) for frequently accessed, read-heavy data. Implement soft-deletes for entities where data retention is required instead of hard deletion.**  
* **Optimal Prompt(s):**  
  * **"Extend the Uphbt.Api to include background job processing using Hangfire. Provide an example of how to offload a long-running task, such as generating a comprehensive bug report (which should retrieve data via service methods that leverage rich domain models but don't directly modify entities), to a background job. Show how to notify the user via SignalR upon job completion. Ensure proper error handling and logging for background jobs. Ensure all method parameters and return types correctly use Nullable Reference Types."**  
  * **"Integrate a caching mechanism (e.g., Redis using `IDistributedCache`) into the Uphbt.Services project for frequently accessed data like user lists or static lookup data. Provide examples of caching data on read operations and invalidating/updating the cache on write operations (via `Uphbt.Services` methods). Ensure the caching logic seamlessly integrates with service layer calls to rich domain entities without impacting domain logic."**

**3.2. Performance Optimization & Monitoring (Backend & Frontend)**

* **Action: Conduct thorough performance profiling on both the backend (.NET diagnostics tools, SQL Server Profiler) and frontends (browser dev tools, Lighthouse). Identify and optimize database query bottlenecks (e.g., adding indexes, optimizing complex joins, addressing N+1 problems). Implement comprehensive structured logging (e.g., Serilog) and integrate with Application Performance Monitoring (APM) tools (e.g., Azure Application Insights) for both backend and frontend for real-time insights into application health and performance.**  
* **Optimal Prompt(s):**  
  * **"Show how to integrate Serilog into the Uphbt.Api project for structured logging. Configure it to log to console and a file, capturing contextual information like `UserPublicId`, request path, and correlating logs across requests (e.g., using `Activity.Current` for tracing). Provide examples of logging various severity levels (Information, Warning, Error) within controllers and services. Ensure proper use of Nullable Reference Types in all logging contexts."**  
  * **"Outline a strategy for basic performance monitoring for both the .NET 9 backend and the Angular 19 frontend. For the backend, suggest key metrics to track (CPU, memory, request latency, database queries) and tools to use (e.g., built-in .NET diagnostic tools, `Prometheus/Grafana` integration example). For the frontend, suggest using browser developer tools and basic performance metrics (e.g., FCP, LCP) and how to log client-side errors effectively."**

**3.3. Deployment Automation (Docker & CI/CD)**

* **Action: Containerize all application components (Uphbt.Api, Angular Frontend, React Frontend) using Docker. Create `docker-compose.yml` for simplified local development and testing of the multi-service application. Design and implement CI/CD pipelines (e.g., GitHub Actions, Azure DevOps Pipelines) for automated build, test, and deployment to staging and production environments. This includes database migration application during deployment.**  
* **Optimal Prompt(s):**  
  * **"Generate Dockerfiles for the Uphbt.Api (.NET 9\) backend, the Uphbt Angular 19 frontend, and the Uphbt React 19 frontend. Provide a `docker-compose.yml` file to orchestrate these three services and a SQL Server container, ensuring correct networking, environment variable configuration for database connection, and proxy settings for local development. Ensure each Dockerfile adheres to best practices for production images (multi-stage builds, minimal base images)."**  
  * **"Provide a basic GitHub Actions CI/CD workflow YAML file for the `uphbt-backend` repository. The workflow should: (1) build the .NET 9 project, (2) run xUnit tests, and (3) publish the build artifacts. Include a separate step for applying EF Core database migrations before running tests (e.g., in an integration testing environment) and for deployment (e.g., to Azure App Service or a container registry)."**

**3.4. Documentation & AI Learnings**

* **Action: Finalize and polish all API documentation generated by Swagger/OpenAPI. Create comprehensive developer documentation covering architectural decisions (e.g., using Architecture Decision Records \- ADRs), code standards, and setup guides. Develop user manuals for both frontend applications. Crucially, compile and review all AI-generated code, ensuring full human understanding, consistency, adherence to best practices, and addressing any "hallucinations" or suboptimal patterns. Document the AI prompt strategies that proved most effective for different tasks (e.g., code generation, test scaffolding, refactoring).**  
* **Optimal Prompt(s):**  
  * **"Provide a template for an Architecture Decision Record (ADR) for the Uphbt project, specifically outlining the decision to use a Rich Domain Model and its implications on the `Uphbt.Domain` and `Uphbt.Services` layers. Include sections for context, decision, consequences, and alternatives considered. Ensure the template encourages clear, concise language and adherence to NRTs where C\# code examples might be included."**  
  * **"Suggest a structured approach for documenting the AI Prompt Strategy used during the Uphbt project development. Outline key categories of prompts (e.g., initial setup, feature generation, bug fixing, refactoring, test generation, cross-framework translation) and for each, provide examples of highly effective prompt patterns (e.g., "Act as a...", "Generate X, ensuring Y, and adhering to Z"). Discuss methods for validating AI output."**  


